{
  "$schema": "../../schemas/resource-schema.json",
  "uri": "examples://workflows/code-review",
  "name": "Code Review Workflow",
  "description": "Complete workflow example for conducting comprehensive code reviews using the OpenAI Assistants API. Includes setup, review process, feedback generation, and follow-up steps with real, executable code examples.",
  "mimeType": "text/markdown",
  "category": "examples",
  "tags": ["workflow", "code-review", "example", "development", "best-practices"],
  "contentType": "markdown",
  "annotations": {
    "audience": "intermediate",
    "priority": "high",
    "lastModified": "2025-01-31T12:37:00.000Z",
    "tags": ["code-review", "workflow", "development", "quality-assurance", "automation"],
    "category": "workflow-examples",
    "version": "1.0.0",
    "author": "OpenAI Assistants MCP Team",
    "usageContext": "Use this workflow when implementing automated code review processes, training development teams on review best practices, or setting up quality assurance pipelines.",
    "prerequisites": ["OpenAI API access", "Understanding of code review principles", "Basic knowledge of development workflows"],
    "relatedResources": ["assistant://templates/coding-assistant", "docs://guides/tool-usage", "docs://best-practices"]
  },
  "content": "# üîç Complete Code Review Workflow\n\nThis comprehensive workflow demonstrates how to conduct thorough code reviews using the OpenAI Assistants API. Perfect for development teams, code mentoring, and quality assurance processes.\n\n## üéØ Workflow Overview\n\n**What This Workflow Covers:**\n- Setting up a specialized code review assistant\n- Analyzing code for quality, security, and performance\n- Generating detailed feedback and suggestions\n- Creating actionable improvement plans\n- Following up on review implementations\n\n**Time Required:** 15-30 minutes per review\n**Skill Level:** Intermediate\n**Use Cases:** Pull request reviews, code mentoring, quality audits\n\n---\n\n## üöÄ Step 1: Create the Code Review Assistant\n\nFirst, let's create a specialized assistant optimized for code reviews:\n\n```json\n{\n  \"tool\": \"assistant-create\",\n  \"arguments\": {\n    \"model\": \"gpt-4\",\n    \"name\": \"Senior Code Reviewer\",\n    \"description\": \"Expert code reviewer specializing in security, performance, and best practices\",\n    \"instructions\": \"You are a senior software engineer and code review expert with 10+ years of experience. Your role is to conduct thorough, constructive code reviews focusing on:\\n\\n## Review Criteria:\\n1. **Code Quality**: Readability, maintainability, and organization\\n2. **Security**: Vulnerability assessment and secure coding practices\\n3. **Performance**: Efficiency, scalability, and resource usage\\n4. **Best Practices**: Design patterns, conventions, and standards\\n5. **Testing**: Test coverage and quality\\n6. **Documentation**: Code comments and documentation\\n\\n## Review Process:\\n1. Analyze the code structure and architecture\\n2. Identify potential issues and improvements\\n3. Provide specific, actionable feedback\\n4. Suggest concrete solutions with examples\\n5. Prioritize issues by severity (Critical, High, Medium, Low)\\n6. Explain the reasoning behind each recommendation\\n\\n## Communication Style:\\n- Be constructive and educational\\n- Provide specific examples and alternatives\\n- Explain the 'why' behind recommendations\\n- Balance criticism with positive feedback\\n- Use clear, professional language\\n\\nAlways structure your reviews with clear sections and prioritized recommendations.\",\n    \"tools\": [\n      { \"type\": \"code_interpreter\" },\n      { \"type\": \"file_search\" }\n    ],\n    \"metadata\": {\n      \"purpose\": \"code_review\",\n      \"expertise\": \"senior_level\",\n      \"focus_areas\": [\"security\", \"performance\", \"quality\", \"best_practices\"]\n    }\n  }\n}\n```\n\n**Expected Response:**\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"id\": \"asst_code_reviewer_123\",\n    \"name\": \"Senior Code Reviewer\",\n    \"model\": \"gpt-4\",\n    \"created_at\": 1706745600\n  }\n}\n```\n\n---\n\n## üìù Step 2: Create Review Thread\n\nSet up a dedicated thread for the code review session:\n\n```json\n{\n  \"tool\": \"thread-create\",\n  \"arguments\": {\n    \"metadata\": {\n      \"review_type\": \"pull_request\",\n      \"project\": \"user-authentication-service\",\n      \"pr_number\": \"#142\",\n      \"author\": \"john.doe\",\n      \"reviewer\": \"ai_assistant\",\n      \"priority\": \"high\",\n      \"created_at\": \"2025-01-31T12:37:00Z\"\n    }\n  }\n}\n```\n\n---\n\n## üîç Step 3: Submit Code for Review\n\nProvide the code that needs to be reviewed:\n\n```json\n{\n  \"tool\": \"message-create\",\n  \"arguments\": {\n    \"thread_id\": \"thread_review_123\",\n    \"role\": \"user\",\n    \"content\": \"Please review this Python authentication service code:\\n\\n```python\\n# auth_service.py\\nimport hashlib\\nimport jwt\\nimport sqlite3\\nfrom datetime import datetime, timedelta\\nfrom flask import Flask, request, jsonify\\n\\napp = Flask(__name__)\\nSECRET_KEY = 'my_secret_key'  # TODO: Move to environment\\n\\nclass AuthService:\\n    def __init__(self):\\n        self.db_path = 'users.db'\\n        self.init_db()\\n    \\n    def init_db(self):\\n        conn = sqlite3.connect(self.db_path)\\n        cursor = conn.cursor()\\n        cursor.execute('''\\n            CREATE TABLE IF NOT EXISTS users (\\n                id INTEGER PRIMARY KEY,\\n                username TEXT UNIQUE,\\n                password_hash TEXT,\\n                email TEXT,\\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\\n            )\\n        ''')\\n        conn.commit()\\n        conn.close()\\n    \\n    def hash_password(self, password):\\n        return hashlib.md5(password.encode()).hexdigest()\\n    \\n    def create_user(self, username, password, email):\\n        conn = sqlite3.connect(self.db_path)\\n        cursor = conn.cursor()\\n        \\n        password_hash = self.hash_password(password)\\n        \\n        try:\\n            cursor.execute(\\n                'INSERT INTO users (username, password_hash, email) VALUES (?, ?, ?)',\\n                (username, password_hash, email)\\n            )\\n            conn.commit()\\n            return {'success': True, 'message': 'User created successfully'}\\n        except sqlite3.IntegrityError:\\n            return {'success': False, 'message': 'Username already exists'}\\n        finally:\\n            conn.close()\\n    \\n    def authenticate_user(self, username, password):\\n        conn = sqlite3.connect(self.db_path)\\n        cursor = conn.cursor()\\n        \\n        password_hash = self.hash_password(password)\\n        \\n        cursor.execute(\\n            'SELECT id, username FROM users WHERE username = ? AND password_hash = ?',\\n            (username, password_hash)\\n        )\\n        \\n        user = cursor.fetchone()\\n        conn.close()\\n        \\n        if user:\\n            token = jwt.encode({\\n                'user_id': user[0],\\n                'username': user[1],\\n                'exp': datetime.utcnow() + timedelta(hours=24)\\n            }, SECRET_KEY, algorithm='HS256')\\n            \\n            return {'success': True, 'token': token}\\n        else:\\n            return {'success': False, 'message': 'Invalid credentials'}\\n\\n@app.route('/register', methods=['POST'])\\ndef register():\\n    data = request.get_json()\\n    auth_service = AuthService()\\n    result = auth_service.create_user(\\n        data['username'], \\n        data['password'], \\n        data['email']\\n    )\\n    return jsonify(result)\\n\\n@app.route('/login', methods=['POST'])\\ndef login():\\n    data = request.get_json()\\n    auth_service = AuthService()\\n    result = auth_service.authenticate_user(\\n        data['username'], \\n        data['password']\\n    )\\n    return jsonify(result)\\n\\nif __name__ == '__main__':\\n    app.run(debug=True)\\n```\\n\\nPlease provide a comprehensive review focusing on security, performance, and best practices. Include specific recommendations and code examples for improvements.\",\n    \"metadata\": {\n      \"code_language\": \"python\",\n      \"file_name\": \"auth_service.py\",\n      \"lines_of_code\": 85,\n      \"review_focus\": [\"security\", \"performance\", \"best_practices\"]\n    }\n  }\n}\n```\n\n---\n\n## ü§ñ Step 4: Run the Code Review\n\nExecute the assistant to perform the review:\n\n```json\n{\n  \"tool\": \"run-create\",\n  \"arguments\": {\n    \"thread_id\": \"thread_review_123\",\n    \"assistant_id\": \"asst_code_reviewer_123\",\n    \"additional_instructions\": \"Please provide a detailed code review with specific examples and prioritized recommendations. Include security vulnerabilities, performance issues, and best practice violations.\",\n    \"metadata\": {\n      \"review_session\": \"session_001\",\n      \"focus_areas\": [\"security\", \"performance\", \"maintainability\"]\n    }\n  }\n}\n```\n\n---\n\n## üìä Step 5: Get Review Results\n\nRetrieve the comprehensive review:\n\n```json\n{\n  \"tool\": \"message-list\",\n  \"arguments\": {\n    \"thread_id\": \"thread_review_123\",\n    \"limit\": 1,\n    \"order\": \"desc\"\n  }\n}\n```\n\n**Expected Review Output:**\n\n```markdown\n# üîç Code Review Report: auth_service.py\n\n## üìã Executive Summary\n- **Overall Quality**: Needs Improvement\n- **Security Risk**: HIGH ‚ö†Ô∏è\n- **Performance**: Medium\n- **Maintainability**: Medium\n- **Critical Issues**: 3\n- **Recommendations**: 8\n\n## üö® Critical Security Issues\n\n### 1. Weak Password Hashing (CRITICAL)\n**Issue**: Using MD5 for password hashing\n```python\n# ‚ùå Current (Vulnerable)\ndef hash_password(self, password):\n    return hashlib.md5(password.encode()).hexdigest()\n```\n\n**Risk**: MD5 is cryptographically broken and vulnerable to rainbow table attacks.\n\n**Solution**: Use bcrypt or Argon2\n```python\n# ‚úÖ Recommended\nimport bcrypt\n\ndef hash_password(self, password):\n    salt = bcrypt.gensalt()\n    return bcrypt.hashpw(password.encode('utf-8'), salt)\n\ndef verify_password(self, password, hashed):\n    return bcrypt.checkpw(password.encode('utf-8'), hashed)\n```\n\n### 2. Hardcoded Secret Key (CRITICAL)\n**Issue**: Secret key exposed in source code\n```python\n# ‚ùå Current (Vulnerable)\nSECRET_KEY = 'my_secret_key'\n```\n\n**Solution**: Use environment variables\n```python\n# ‚úÖ Recommended\nimport os\nSECRET_KEY = os.environ.get('JWT_SECRET_KEY')\nif not SECRET_KEY:\n    raise ValueError(\"JWT_SECRET_KEY environment variable is required\")\n```\n\n### 3. SQL Injection Prevention (MEDIUM)\n**Current**: Using parameterized queries ‚úÖ\n**Recommendation**: Continue this practice, consider using an ORM\n\n## ‚ö° Performance Issues\n\n### 1. Database Connection Management\n**Issue**: Creating new connections for each operation\n```python\n# ‚ùå Current (Inefficient)\ndef create_user(self, username, password, email):\n    conn = sqlite3.connect(self.db_path)  # New connection each time\n```\n\n**Solution**: Use connection pooling\n```python\n# ‚úÖ Recommended\nfrom contextlib import contextmanager\n\n@contextmanager\ndef get_db_connection(self):\n    conn = sqlite3.connect(self.db_path)\n    try:\n        yield conn\n    finally:\n        conn.close()\n```\n\n## üèóÔ∏è Architecture & Best Practices\n\n### 1. Separation of Concerns\n**Issue**: Flask routes directly instantiate AuthService\n\n**Solution**: Use dependency injection\n```python\n# ‚úÖ Recommended\nauth_service = AuthService()  # Global instance\n\n@app.route('/register', methods=['POST'])\ndef register():\n    data = request.get_json()\n    result = auth_service.create_user(\n        data['username'], \n        data['password'], \n        data['email']\n    )\n    return jsonify(result)\n```\n\n### 2. Input Validation\n**Missing**: No input validation on endpoints\n\n**Solution**: Add validation\n```python\n# ‚úÖ Recommended\nfrom marshmallow import Schema, fields, ValidationError\n\nclass UserRegistrationSchema(Schema):\n    username = fields.Str(required=True, validate=Length(min=3, max=50))\n    password = fields.Str(required=True, validate=Length(min=8))\n    email = fields.Email(required=True)\n\n@app.route('/register', methods=['POST'])\ndef register():\n    schema = UserRegistrationSchema()\n    try:\n        data = schema.load(request.get_json())\n    except ValidationError as err:\n        return jsonify({'success': False, 'errors': err.messages}), 400\n```\n\n## üìù Additional Recommendations\n\n### 1. Error Handling\n- Add comprehensive exception handling\n- Implement proper logging\n- Return consistent error responses\n\n### 2. Testing\n- Add unit tests for AuthService methods\n- Add integration tests for API endpoints\n- Mock database operations in tests\n\n### 3. Configuration\n- Move all configuration to environment variables\n- Add configuration validation\n- Support different environments (dev, staging, prod)\n\n### 4. Security Headers\n- Add CORS configuration\n- Implement rate limiting\n- Add security headers (CSRF, XSS protection)\n\n## üéØ Priority Action Items\n\n1. **IMMEDIATE** (Critical): Replace MD5 with bcrypt\n2. **IMMEDIATE** (Critical): Move secret key to environment\n3. **HIGH**: Add input validation\n4. **HIGH**: Implement proper error handling\n5. **MEDIUM**: Optimize database connections\n6. **MEDIUM**: Add comprehensive tests\n7. **LOW**: Refactor for better separation of concerns\n8. **LOW**: Add security headers\n\n## ‚úÖ What's Done Well\n\n- ‚úÖ Using parameterized SQL queries\n- ‚úÖ Proper database table structure\n- ‚úÖ Clear method organization\n- ‚úÖ RESTful API design\n\n**Estimated Effort**: 2-3 days for critical fixes, 1 week for full improvements\n```\n\n---\n\n## üîÑ Step 6: Follow-up Questions\n\nAsk specific questions about the review:\n\n```json\n{\n  \"tool\": \"message-create\",\n  \"arguments\": {\n    \"thread_id\": \"thread_review_123\",\n    \"role\": \"user\",\n    \"content\": \"Thank you for the comprehensive review! I have a few follow-up questions:\\n\\n1. Can you provide a complete example of how to implement bcrypt password hashing with the existing database structure?\\n\\n2. What's the best way to implement rate limiting for the login endpoint to prevent brute force attacks?\\n\\n3. Can you suggest a specific testing strategy for this authentication service?\"\n  }\n}\n```\n\n```json\n{\n  \"tool\": \"run-create\",\n  \"arguments\": {\n    \"thread_id\": \"thread_review_123\",\n    \"assistant_id\": \"asst_code_reviewer_123\"\n  }\n}\n```\n\n---\n\n## üìà Step 7: Track Review Progress\n\nCreate a follow-up thread to track implementation:\n\n```json\n{\n  \"tool\": \"thread-create\",\n  \"arguments\": {\n    \"metadata\": {\n      \"review_type\": \"follow_up\",\n      \"original_review\": \"thread_review_123\",\n      \"implementation_status\": \"in_progress\",\n      \"priority_items\": [\"bcrypt_implementation\", \"env_variables\", \"input_validation\"]\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool\": \"message-create\",\n  \"arguments\": {\n    \"thread_id\": \"thread_followup_456\",\n    \"role\": \"user\",\n    \"content\": \"I've implemented the bcrypt password hashing. Here's the updated code:\\n\\n```python\\n# Updated password handling\\nimport bcrypt\\nimport os\\n\\nclass AuthService:\\n    def __init__(self):\\n        self.db_path = os.environ.get('DB_PATH', 'users.db')\\n        self.init_db()\\n    \\n    def hash_password(self, password):\\n        salt = bcrypt.gensalt()\\n        return bcrypt.hashpw(password.encode('utf-8'), salt)\\n    \\n    def verify_password(self, password, hashed):\\n        return bcrypt.checkpw(password.encode('utf-8'), hashed)\\n    \\n    def create_user(self, username, password, email):\\n        # ... existing code ...\\n        password_hash = self.hash_password(password)\\n        # ... rest of method\\n    \\n    def authenticate_user(self, username, password):\\n        conn = sqlite3.connect(self.db_path)\\n        cursor = conn.cursor()\\n        \\n        cursor.execute(\\n            'SELECT id, username, password_hash FROM users WHERE username = ?',\\n            (username,)\\n        )\\n        \\n        user = cursor.fetchone()\\n        conn.close()\\n        \\n        if user and self.verify_password(password, user[2]):\\n            # Generate JWT token\\n            # ... existing token code\\n        else:\\n            return {'success': False, 'message': 'Invalid credentials'}\\n```\\n\\nCan you review this implementation and suggest any improvements?\"\n  }\n}\n```\n\n---\n\n## üéØ Workflow Benefits\n\n### For Development Teams\n- **Consistent Reviews**: Standardized review criteria\n- **Educational**: Learn best practices through detailed explanations\n- **Efficient**: Faster than manual reviews for initial assessment\n- **Comprehensive**: Covers security, performance, and maintainability\n\n### For Code Quality\n- **Early Detection**: Catch issues before they reach production\n- **Knowledge Sharing**: Spread best practices across the team\n- **Documentation**: Create review records for future reference\n- **Continuous Improvement**: Track common issues and patterns\n\n### For Mentoring\n- **Detailed Explanations**: Understand the 'why' behind recommendations\n- **Practical Examples**: See correct implementations\n- **Progressive Learning**: Build skills through guided reviews\n- **Safe Environment**: Learn without judgment\n\n---\n\n## üîß Customization Options\n\n### Review Focus Areas\nCustomize the assistant for different review types:\n\n```json\n// Security-focused review\n{\n  \"additional_instructions\": \"Focus primarily on security vulnerabilities, authentication flaws, and data protection issues.\"\n}\n\n// Performance-focused review\n{\n  \"additional_instructions\": \"Emphasize performance optimization, scalability concerns, and resource efficiency.\"\n}\n\n// Architecture review\n{\n  \"additional_instructions\": \"Concentrate on code organization, design patterns, and maintainability aspects.\"\n}\n```\n\n### Language-Specific Reviews\nAdapt for different programming languages:\n\n```json\n{\n  \"instructions\": \"You are a JavaScript/Node.js expert focusing on modern ES6+ practices, async/await patterns, and npm security...\"\n}\n```\n\n---\n\n## üìö Best Practices for Code Reviews\n\n### 1. **Preparation**\n- Provide context about the code's purpose\n- Include relevant documentation or requirements\n- Specify areas of particular concern\n\n### 2. **Review Process**\n- Start with high-level architecture\n- Focus on security and performance first\n- Consider maintainability and readability\n- Check for proper testing\n\n### 3. **Follow-up**\n- Track implementation of recommendations\n- Re-review critical changes\n- Document lessons learned\n- Update team guidelines based on findings\n\n### 4. **Team Integration**\n- Use reviews as learning opportunities\n- Share interesting findings with the team\n- Create coding standards based on common issues\n- Celebrate improvements and good practices\n\n---\n\n## üîó Related Resources\n\n- **Assistant Template**: `assistant://templates/coding-assistant`\n- **Tool Usage Guide**: `docs://guides/tool-usage`\n- **Best Practices**: `docs://best-practices`\n- **Getting Started**: `docs://guides/getting-started`\n\n---\n\n**Ready to implement automated code reviews? Start with this workflow and customize it for your team's specific needs!** üöÄ"
}